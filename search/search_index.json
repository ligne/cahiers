{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>I'm one of those people who always has hundreds of open tabs across a dozen windows of multiple browsers. Partly this is because I'm bad at tidying them up when I'm done, but for the most part it's because they contain something that is useful (or that I feel might be useful), just not quite yet.</p> <p>I'm hoping that by writing them down here, I will be able to find them later when I actually need them.</p>"},{"location":"git/","title":"Git","text":"<p>Everyone's favourite VCS.</p>"},{"location":"git/#index","title":"Index","text":""},{"location":"git/#view-changes-to-the-index","title":"View changes to the index","text":"<p>By default <code>git diff</code> only shows unstaged changes. Add <code>--staged</code> to see what changes are staged for the next commit, or run <code>git diff HEAD</code> to see all changes relative to the last commit.</p>"},{"location":"git/#unstage-files","title":"Unstage files","text":"<p>This is just a simple <code>git reset</code>, or <code>git reset HEAD -- $file ...</code> to be more discerning.</p>"},{"location":"git/#commits","title":"Commits","text":""},{"location":"git/#undo-the-last-commit","title":"Undo the last commit","text":"<p>To undo the most recent commit ready for another try: <code>git reset --soft HEAD^</code>.</p> <p>The old commit will still be available as <code>ORIG_HEAD</code>. Add <code>-c ORIG_HEAD ...</code> when committing to use it as the basis of the new message.</p>"},{"location":"git/#squashing","title":"Squashing","text":"<p>In the general case this can be done an interactive rebase, and the last commit can be corrected with <code>git add ...; git commit --amend [--no-edit]</code>. But if the last few commits are a mess that need squashing into one, run <code>git reset --soft HEAD~n</code> and prepare the final commit.</p>"},{"location":"git/#branches","title":"Branches","text":""},{"location":"git/#turn-commits-into-a-new-branch","title":"Turn commits into a new branch","text":"<p>To turn the most recent commits into a new branch:</p> <pre><code>git branch new_branch\ngit reset --hard HEAD~3  # use the three most recent commits\ngit switch new_branch\n</code></pre>"},{"location":"git/#find-merged-branches","title":"Find merged branches","text":"<p>List all branches that have(n't) been merged into the current branch: <code>git branch --{,no-}merged</code>. Can specify a branch name to use instead, and <code>-r</code> and <code>-a</code> to show remote or all branches respectively. (source)</p>"},{"location":"git/#rename-a-branch","title":"Rename a branch","text":"<p>Change the branch name locally: <code>git branch --move old-name new-name</code>.</p> <p>If it also exists upstream, <code>git push --set-upstream origin new-name; git push origin --delete old-name</code>.</p>"},{"location":"git/#merging","title":"Merging","text":""},{"location":"git/#stash","title":"Stash","text":""},{"location":"git/#converting-to-a-branch","title":"Converting to a branch","text":"<p>Useful when the stash entry can no longer be popped cleanly. <code>git stash branch testchanges</code>.</p>"},{"location":"git/#gitignore","title":".gitignore","text":"<p>If you add rules to ignore vim droppings and similar in <code>~/.config/git/ignore</code>, you don't need to add them to every project you create. It's obvious when you think about it, isn't it?</p> <p>There is a collection of per-language rules here.</p> <p>To ignore something that's only relevant locally or for a short time: <code>echo boring/ &gt;&gt; .git/info/exclude</code>. If it's a directory, doing <code>echo \\* &gt; boring/.gitignore</code> means the ignore will automatically get cleaned up when it's deleted. Some tools (including <code>uv</code>, <code>pytest</code> and <code>mypy</code>) do this automatically to their cache directories, so check before ignoring them explicitly.</p>"},{"location":"markdown/","title":"Markdown","text":"<p>The markup language this is written in.</p> <p>Cheat-sheets here and here.</p>"},{"location":"markdown/#pre-commit","title":"pre-commit","text":""},{"location":"markdown/#formatter","title":"Formatter","text":"<p><code>mdformat</code> is like <code>black</code> for Markdown files. Probably want to use it in conjunction with <code>mdformat-mkdocs</code>.</p> <p><code>.pre-commit-config.yaml</code> snippet here.</p> <p>There are a variety of plugins. For the most part these either format the contents of code blocks, or add support for Markdown extensions.</p>"},{"location":"mkdocs/","title":"MkDocs","text":"<p>MkDocs is the static site generator used for this site.</p>"},{"location":"mkdocs/#initialising","title":"Initialising","text":"<p>In a clean directory:</p> <pre><code>uv pip install mkdocs\nmkdocs new .\n</code></pre>"},{"location":"mkdocs/#editing","title":"Editing","text":"<p>Create Markdown files in the <code>docs/</code> directory.</p> <p>Non-markdown files can go alongside them and will be copied as-is.</p> <p>MkDocs comes with a test server that automatically reloads on changes:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"mkdocs/#images","title":"Images","text":"<ul> <li>Put them in <code>docs/img</code>. Reference with the usual syntax: <code>![alt text](img/name_of_file.png)</code>.</li> <li>Custom favicon: the standard MkDocs will use <code>docs/img/favicon.ico</code> if present.     Material for MkDocs prefers <code>assets/images/favicon.png</code> but this can be overridden in the config.</li> </ul>"},{"location":"mkdocs/#redirects","title":"Redirects","text":"<p>To avoid link-rot when moving pages about, use the <code>mkdocs-redirects</code> plugin:</p> <pre><code>plugins:\n  - redirects:\n      redirect_maps:\n        \"old-path.md\": \"new/path.md\"\n</code></pre> <p>However redirecting anchors needs to be done within the browser. See uv's codebase for one possible implementation.</p>"},{"location":"mkdocs/#navigation","title":"Navigation","text":"<p>Material for MkDocs has a lot of interesting options. If these are not enough, there's always Awesome Nav.</p>"},{"location":"mkdocs/#deploying","title":"Deploying","text":"<p>Full documentation here. The gist is: run <code>mkdocs gh-deploy</code> and it will soon appear on your github site.</p> <p>There is a GitHub Action to do this.</p>"},{"location":"pre-commit/","title":"pre-commit","text":"<p>pre-commit is a tool for managing git hooks. It runs various checks automatically on every commit, preventing syntax or formatting errors from being introduced.</p>"},{"location":"pre-commit/#initialising","title":"Initialising","text":"<pre><code>uv tool install pre-commit  # installs it globally\npre-commit sample-config &gt; .pre-commit-config.yaml\npre-commit install\n</code></pre>"},{"location":"pre-commit/#configuring","title":"Configuring","text":"<p>Configuration goes in <code>.pre-commit-config.yaml</code>. Validate it with <code>pre-commit validate-config .pre-commit-config.yaml</code>. Documentation is here.</p>"},{"location":"pre-commit/#some-useful-hooks","title":"Some useful hooks","text":"<ul> <li>Markdown</li> <li>Spell-checking code and prose</li> <li>Many more here</li> </ul> <p>It's also possible to write your own.</p>"},{"location":"pre-commit/#operating","title":"Operating","text":"<p>It runs automatically before every commit, on the files being committed. If any of the hooks fail, the commit will be aborted.</p> <p>Many tools can automatically fix errors they find. For this reason it works best if the changes are added as a separate step before commit, as these changes can be reviewed with <code>git diff</code>.</p> <p>You can also run it manually with <code>pre-commit run</code>. By default this only operates on staged files; check specific files with <code>--files</code>, or select them all with <code>--all-files</code>.</p> <p>Even when invoked manually it will refuse to run while there are uncommitted changes to the configuration file. The <code>--files</code> or <code>--all-files</code> options override this.</p> <p>Occasionally run <code>pre-commit autoupdate</code> to keep the hooks up-to-date.</p>"},{"location":"pre-commit/#overriding","title":"Overriding","text":"<p>It's still possible to force a commit that would normally be rejected. Either <code>SKIP=hook1,hook2 git commit</code> to ignore specific hooks, or <code>git commit --no-verify</code> to ignore the whole lot.</p>"},{"location":"pre-commit/#troubleshooting","title":"Troubleshooting","text":"<p>Solutions to some common problems.</p>"},{"location":"spelling/","title":"Spelling","text":""},{"location":"spelling/#pre-commit","title":"pre-commit","text":"<p>The following tools play well with <code>pre-commit</code>:</p> <p><code>typos</code></p> <ul> <li>Aimed at finding common misspellings in code rather than acting as a general-purpose spellchecker.</li> <li>Very fast.</li> </ul> <p>Relatively few configuration options. It can use its own <code>.typos.toml</code>, but it can also be included in <code>pyproject.toml</code>.</p> <p><code>cspell</code></p> <ul> <li>Fully-fledged spellchecker, using a much more comprehensive dictionary.</li> <li>Significantly slower.</li> </ul> <p>Configure it using <code>.cspell.yaml</code>. A basic guide, including how to seed a local dictionary quickly, and a detailed reference. In addition to specifying additional project-local words, these custom dictionaries are very flexible.</p>"}]}